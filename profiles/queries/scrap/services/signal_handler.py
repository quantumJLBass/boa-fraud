# signal_handler.py
import os
import signal
import traceback
from typing import Any

import psutil
from loguru import logger

import gs
from services.webdriver import terminate_driver, terminate_vpn
from settings.settings import *


def signal_handler(sig: int, frame: Any) -> None:
    """
    Handles termination signals (SIGINT, SIGTERM, SIGABRT, SIGBREAK) and performs cleanup
    by terminating the WebDriver and VPN processes, logging the termination, and exiting the program.

    Args:
        sig (int): The signal number.
        frame (Any): The current stack frame.

    Returns:
        None
    """
    if gs.terminate_in_progress:
        logger.info(
            f"{i()}ğŸ–ï¸ğŸ“› Signal received but termination already in progress. Ignoring..."
        )
        return

    gs.terminate_in_progress = True
    logger.info(f"{i()}ğŸ›‘ Signal {sig} received: cleaning up resources and exiting...")
    logger.info(f"{i()}ğŸ–ï¸ğŸ“› hade a frame of {frame}")

    try:
        terminate_driver()
    except Exception as e:
        logger.error(f"{i()}ğŸ“› Error terminating driver: {e}")
        logger.error(traceback.format_exc())

    try:
        terminate_vpn()
    except Exception as e:
        logger.error(f"{i()}ğŸ“› Error terminating VPN: {e}")
        logger.error(traceback.format_exc())

    # Ensure all child processes are terminated
    logger.info(f"{i()}ğŸ”ª Killing all child processes...")
    try:
        # Terminate all child processes of the current process
        current_process = psutil.Process()
        children = current_process.children(recursive=True)
        for child in children:
            logger.info(
                f"{i()}ğŸ”ª Terminating child process {child.pid} ({child.name()})"
            )
            child.terminate()
        _, still_alive = psutil.wait_procs(children, timeout=5)
        for child in still_alive:
            logger.info(
                f"{i()}ğŸ”ª Force killing child process {child.pid} ({child.name()})"
            )
            child.kill()
    except Exception as e:
        logger.error(f"{i()}ğŸ“› Error terminating child processes: {e}")
        logger.error(traceback.format_exc())

    # Forcefully exit the program
    logger.info(f"{i()}ğŸƒ Exiting program.")
    os._exit(0)


def setup_signal_handling() -> None:
    """
    Sets up signal handlers for termination signals (SIGINT, SIGTERM, SIGABRT, SIGBREAK).

    This function sets up signal handlers for the following signals:
    - SIGINT: Interrupt signal, typically generated by pressing Ctrl+C in the terminal.
    - SIGTERM: Termination signal, typically generated by the operating system to request the program to terminate.
    - SIGABRT: Abort signal, typically generated by the program itself to indicate an unrecoverable error.
    - SIGBREAK: Break signal, typically generated by pressing Ctrl+Break in the terminal.

    When a termination signal is received, the `signal_handler` function is called to perform cleanup,
    terminate the WebDriver and VPN processes, log the termination, and exit the program.

    This function does not take any parameters and does not return anything.
    """
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGABRT, signal_handler)
    signal.signal(signal.SIGBREAK, signal_handler)
    # signal.signal(signal.SIGKILL, signal_handler)
    # signal.signal(signal.CTRL_C_EVENT, signal_handler)
    # signal.signal(signal.CTRL_BREAK_EVENT, signal_handler)
    # signal.signal(signal.SIGSTOP, signal_handler)


def check_and_terminate() -> None:
    """
    A utility function to be run at regular intervals in every major function or loop
    to check if the app needs to be terminated.
    """
    if gs.terminate_in_progress:
        logger.info(f"{i()}ğŸ Termination requested. Exiting current process...")
        signal_handler(signal.SIGTERM, None)
